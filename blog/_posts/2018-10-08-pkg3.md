---
layout: post
title:  Julia's New Package Manager
author: Stefan Karpinski
---

Julia 1.0 ships with a brand-new built-in package manager. This new package manager, code named "Pkg3" during its development, takes a fairly different approach from typical package managers, including Julia's previous two built-in package managers (Pkg1 and Pkg2, also designed by yours truly). Package managers have traditionally aimed to "just" automate the installation and configuration of packages on the current system. And this is truly a noble and useful thing to streamline! Pkg3, is more ambitious and as a result can be a bit of a novel experience at times. By explaining how it works, and even more importantly _why_ it works that way, I hope that I can help people to understand the new package manager and make good use of it to make their lives easier. And even if you're not a Julia user (yet!) the philosophy and design principles of Pkg3 may be of interest.

### Implicit global mutable state

What does the following simple Julia code do?

```julia
import JSON

v = JSON.parse("[1,2,3]")
```

This code snippet looks fairly straightforward and seems to result in `v == [1, 2, 3]`, but of course, I wouldn't be asking if it was that simple. It's a trick question. The correct answer is: *who knows?* In Julia 0.6 and earlier, in order to have any idea what this code actually does, one needs to know what `import JSON` does and that depends on what files and directories happen to exist on the computer where Julia is running. This code could literally do anything. Print `Hello, world` and then exit—or delete all the files in your home directory. It all depends on what happens to be on your hard drive, which is what we will describe as *implicit global mutable state*:

- It's <u>implicit</u> because there's no good way to record it: it's just there and used implicitly.
- It's <u>global</u> because it's shared between all the different projects and Julia process on your system.
- It's <u>mutable</u> because you can change it.

To a large extent, the premise of Pkg3 and changes to code loading in Julia 1.0 are to take the implicit global mutable state that determined what something like `import JSON` meant previously and make it explicit, local and immutable.



Worse still, there's no good way to capture that information. Because of this, the meaning of any program that has external dependencies depends entirely on 

One of the first goals of Pkg3 is to eliminate this 

What's the problem with the way most package managers work? As with so many things in computing, the problem, is **implicit global mutable state**. That's pretty much the main thing that traditional package managers are about: the state of packages installed on your system. Perhaps an example will help motivate the problem. What does this code do?:

```julia
using Distributions


```



So why The only issue is that 



that one wants to install and use on whatever computer one happens to be running code on and have done so in a global way—what's installed and visible to use from one project is the same as what's available to every other project on the same system. 