---
layout: post
title:  Julia's New Package Manager
author: Stefan Karpinski
---

Julia 1.0 has a brand new package manager. This package manager, code named "Pkg3", takes a different approach than traditional package managers, including the previous two iterations of Julia's. Package managers traditionally aim to automate the installation and configuration of a shared global set of packages on a particular computer. Pkg3 does this too, of course, but it also aims to do more. This ambition means it works a little differently than you might be used to, which can be confusing at first. In this post, I'll explain the philosophy behind Pkg3 and *why* it works the way it does.

### Eliminating implicit global mutable state

Consider the following Julia code:

```julia
import JSON

v = JSON.parse("[1, 2, 3]")
```

What does this snippet do? It looks fairly straightforward: it should result in having `v == [1, 2, 3]`. Of course, I wouldn't be asking if it was that simple, it's a trick question. The correct answer is: *Who knows? It could do literally anything!* In order to have any idea what this code actually does, one needs to know what `import JSON` does and that depends on what files happen to exist on the computer where you're running the code. It could print "Hello, world" and then exit. Or it could delete all your files. It all depends on what happens to be on your hard drive. So the behavior of this code is very much not self-contained. It depends on what we will call *implicit global mutable state*:

- **Implicit** because it's not explicitly written down anywhere, it's just what happens to be installed.
- **Global** because it's shared between all the different Julia projects and processes on your system.
- **Mutable** because you can change it at any timeâ€”there's no way to refer to a permanent state.

The fundamental premise of Pkg3 is to take all of this implicit global mutable state and make it *explicit, local and immutable* instead:

- **Explicit** by recording what exactly `import JSON` means. We store this in two files: `Project.toml` and `Manifest.toml`, which can be checked into version control and tracked just like any other source code. They spell out exactly what package `JSON` is and exactly what version of `JSON` should be loaded.
- **Local** by allowing different projects to have their own `Project.toml` and `Manifest.toml` files. What `import JSON` means in each project is independent. They can use different versions of the same `JSON` package or they could even use unrelated packages that both happen to be called `JSON`.
- **Immutable** by committing `Project.toml` and `Manifest.toml` into version control. Each dependency is identified by a permanently assigned UUID and each version of each dependency is identified by a cryptographic hash of its source tree. Once committed into version control, this records the dependencies of a project at that commit as permanently as it records the source of the project itself.

